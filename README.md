# 📊 eBPF-based TCP State Modeling for Slow HTTP Attack Detection

This project implements a lightweight, kernel-assisted detection approach for slow HTTP attacks (e.g., slow HTTP Header/Body/Read attacks), by modeling TCP state transitions and evaluating abnormal behaviors using **Jensen-Shannon (JS) divergence**.

> ⚠️ **Detection only** — this project focuses solely on identifying abnormal behavior. It does not include mitigation or active defense mechanisms.

---

## 🧠 Core Idea

By tracing TCP state transitions in real time via eBPF (attached to `kprobe__tcp_set_state`), we capture per-connection state transitions. User-space programs then collect these events and calculate the **JS divergence** from a learned baseline distribution. This allows us to detect anomalies in system-wide behavior—particularly those caused by slow HTTP attacks.

---

## 📁 Project Structure

```
ebpf_JS_tcp_state/
├── user_jsdiv.py                # Main detection script: performs live monitoring, JS divergence calculation, and saves results
├── collect_baseline_short.py    # Baseline collector: gathers normal behavior over time (sliding window average)
├── AA_tcp_state_kl_kernel/      # Early attempt at in-kernel JS divergence; partial and under development
├── Data_analysis/               # Jupyter notebooks for data analysis and JS/KL evaluation
├── .build/                      # Your local libbpf + bpftool build artifacts (adjust path in Makefile)
├── README.md
└── ...
```

---

## 📜 File Descriptions

### 🔍 `user_jsdiv.py`

* Main user-space script for online detection.
* Attaches to kernel probe (`tcp_set_state`) via eBPF and tracks state transitions.
* Calculates JS divergence between observed behavior and a baseline (e.g., `baseline.json`).
* Stores:

  * **Live output**
  * **JS divergence values**
  * **CPU and memory usage statistics** (as `.csv` and `.json`)

### 🧪 `collect_baseline_short.py`

* Captures **normal system behavior** using a 10-second sliding window over 6 intervals.
* Stores averaged transition statistics as `.json`.
* Use this to validate feasibility and extract meaningful thresholds.

### 📂 `Data_analysis/`

* Contains all Jupyter notebooks for data visualization and divergence analysis.
* Includes:

  * `Probability_distribution_statistics.ipynb`: Visualizes collected distributions (see: [Notebook](https://github.com/awmwl/ebpf_JS_tcp_state/blob/main/Data_analysis/Probability_distribution_statistics.ipynb))
  * `allJSKL.ipynb`: Compares JS vs KL divergence (see: [Notebook](https://github.com/awmwl/ebpf_JS_tcp_state/blob/main/Data_analysis/allJSKL.ipynb))
  * `js_threshold_analysis.ipynb`: Threshold tuning and generation of `baseline.json` (see: [Notebook](https://github.com/awmwl/ebpf_JS_tcp_state/blob/main/Data_analysis/js_threshold_analysis.ipynb))

👉 A separate `README.md` exists in the `Data_analysis/` folder with more details.

### ⚙️ `AA_tcp_state_kl_kernel/`

* Initial proof-of-concept for **fully in-kernel** detection.
* Not yet fully functional; needs:

  1. Replace KL with JS divergence.
  2. Implement log() using **lookup tables** (no floating point support in eBPF).
  3. Modify `Makefile` for your environment — built with `libbpf` + CO-RE.

     * `.build/` holds compiled `libbpf` and `bpftool` binaries (customize as needed).

---

## 📊 Dataset Overview (from `Data_analysis/`)

All datasets are generated by `collect_baseline_short.py`, unless stated otherwise:

| Folder        | Description                                                                                                                                       |
| ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- |
| `normal/`     | Normal traffic with occasional bursts. <br> Script: [`legit_with_burst.sh`](https://github.com/awmwl/ebpf_xdp_ddos/blob/main/legit_with_burst.sh) |
| `normallong/` | Extended normal trace (10 minutes).                                                                                                               |
| `attack/`     | **Slow HTTP Header** attack (holds incomplete headers).<br>**Command:** ```slowhttptest -c 1000 -H -i 10 -r 200 -t GET -u http://192.168.254.142:8080 -x 24 -p 3```                                           |
| `ddosattack/` | Standard DDoS test.<br> Script: [`run_attacks.sh`](https://github.com/awmwl/ebpf_xdp_ddos/blob/main/run_attacks.sh)                               |
| `attackbody/` | **Slow HTTP Body** attack with large `Content-Length`.<br>**Command:** ```slowhttptest -c 1000 -B -g -o my_body_stats -i 110 -r 200 -s 8192 -t FAKEVERB -u http://192.168.254.142:8080 -x 10 -p 3```                                                                                            |
| `attackread/` | **Slow HTTP Read** attack (client reads very slowly).<br>**Command:** ```slowhttptest -c 1000 -X -r 1000 -w 10 -y 20 -n 5 -z 32 -u http://192.168.254.142:8080```                                                                                             |
| `mix/`        | Combined normal + slow HTTP Header attack traffic.                                                                                                |

---

## 📌 Notes

* **Why JS divergence?** See `Data_analysis/allJSKL.ipynb` — JS was more stable and discriminative across observed patterns.
* **eBPF constraints:** No floating-point support; JS calculation must use lookup tables for `log(x)` operations.
* **Compatibility:** This project uses **libbpf + CO-RE** style. You need a modern kernel and toolchain.
* Adjust `Makefile` and `.build/` paths to fit your environment.

---

## 📦 Dependencies

* Python ≥ 3.7
* JupyterLab or Notebook
* [`slowhttptest`](https://github.com/shekyan/slowhttptest) for simulating attacks 
* eBPF build environment:

  * Clang/LLVM
  * libbpf (manually built or system-wide)
  * bpftool (optional for debugging)

